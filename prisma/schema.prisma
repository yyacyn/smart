generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// Required for creating a User: id, name, email, image, cart (optional JSON string)
model User {
  id           String   @id
  name         String
  email        String
  image        String
  cart         Json     @default("{}")
  registeredAt DateTime @default(now())

  // Relations
  ratings          Rating[]
  Address          Address[]
  store            Store?
  buyerOrders      Order[]    @relation("BuyerRelation")
  wishlists        Wishlist[]
  messagesSent     Message[]  @relation("SentMessages")
  messagesReceived Message[]  @relation("ReceivedMessages")
  reporter         Report[]   @relation("reporterRelation")
}

model Product {
  id          String   @id @default(cuid())
  name        String
  description String
  mrp         Float
  price       Float
  images      String[]
  categoryId  String?
  inStock     Boolean  @default(true)
  storeId     String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // ðŸ”¹ Tambahan baru (tidak merusak data lama)
  stock             Int       @default(0)
  minStock          Int?      @default(0)
  weight            String?
  dimensions        String?
  model             String?
  additionalInfo    String?
  status            String    @default("draft")
  sku               String?   @unique
  barcode           String?   @unique
  shippingWeight    String?
  shippingLength    String?
  shippingWidth     String?
  shippingHeight    String?
  warranty          String?
  returnPolicy      String?
  tags              String?
  metaTitle         String?
  metaDescription   String?

  // ðŸ”¹ Relasi tambahan untuk varian produk
  variants          ProductVariant[]

  // Existing relations
  store      Store       @relation(fields: [storeId], references: [id], onDelete: Cascade)
  category   Category?   @relation(fields: [categoryId], references: [id])
  orderItems OrderItem[]
  rating     Rating[]
  wishlists  Wishlist[]
}

model ProductVariant {
  id        String   @id @default(cuid())
  productId String
  variant   String
  stock     Int      @default(0)

  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
}

enum OrderStatus {
  ORDER_PLACED
  PROCESSING
  SHIPPED
  DELIVERED
}

enum PaymentMethod {
  COD
  BANK_TRANSFER
}

// Required for creating an Order: total, userId, storeId, addressId, isPaid, paymentMethod, isCouponUsed, coupon (JSON), orderItems (nested)
model Order {
  id            String        @id @default(cuid())
  total         Float
  status        OrderStatus   @default(ORDER_PLACED)
  userId        String
  storeId       String
  addressId     String
  isPaid        Boolean       @default(false)
  paymentMethod PaymentMethod
  notes         String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  isCouponUsed  Boolean       @default(false)
  coupon        Json          @default("{}")
  orderItems    OrderItem[]
  // Timeline for status changes
  statusHistory OrderStatusHistory[]

  // Relations
  user    User    @relation("BuyerRelation", fields: [userId], references: [id])
  store   Store   @relation(fields: [storeId], references: [id])
  address Address @relation(fields: [addressId], references: [id])
}

// Required for creating an OrderItem: orderId, productId, quantity, price
model OrderItem {
  orderId   String
  productId String
  quantity  Int
  price     Float

  // Relations
  order   Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id])

  @@id([orderId, productId])
}

// Required for creating a Rating: rating, review, userId, productId
model Rating {
  id        String   @id @default(cuid())
  rating    Int
  review    String
  userId    String
  productId String
  orderId   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([userId, productId, orderId])
}

// Required for creating an Address: userId, name, email, street, city, state, zip, country, phone
model Address {
  id        String   @id @default(cuid())
  userId    String
  name      String
  email     String
  street    String
  city      String
  state     String
  zip       String
  country   String
  phone     String
  createdAt DateTime @default(now())

  // Relations
  Order Order[]
  user  User    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Required for creating a Coupon: code, description, discount, forNewUser, isPublic, expiresAt
model Coupon {
  code        String   @id
  description String
  discount    Float
  forNewUser  Boolean
  forMember   Boolean  @default(false)
  isPublic    Boolean
  expiresAt   DateTime
  createdAt   DateTime @default(now())
}

// Required for creating a Store: userId, name, username, email, contact, logo, description, address (optional: , status, isActive)
model Store {
  id          String @id @default(cuid())
  userId      String @unique
  name        String
  username    String @unique
  description String
  address     String
  email       String
  contact     String
  logo        String

  // Tambahan disarankan:
  website         String? // Website resmi toko (optional)
  categoryId      String? // Relasi ke kategori
  establishedDate DateTime? // Tanggal berdiri
  statusReason    String? // Alasan perubahan status
  isActive        Boolean   @default(false)
  status          String    @default("pending")

  // Relasi
  user     User      @relation(fields: [userId], references: [id])
  category Category? @relation(fields: [categoryId], references: [id])
  Product  Product[]
  Order    Order[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Message {
  id         String   @id @default(cuid())
  senderId   String
  receiverId String
  content    String
  createdAt  DateTime @default(now())

  sender   User @relation("SentMessages", fields: [senderId], references: [id])
  receiver User @relation("ReceivedMessages", fields: [receiverId], references: [id])
}

// Wishlist feature: map users to products they like
model Wishlist {
  id        String   @id @default(cuid())
  userId    String
  productId String
  createdAt DateTime @default(now())

  // Relations
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([userId, productId])
}

model Category {
  id               String           @id @default(cuid())
  name             String
  description      String? // optional
  image            String? // optional (URL)
  status           CategoryStatus @default(ACTIVE)
  slug             String         @unique
  metaTitle        String? // optional
  metaDescription  String? // optional
  sortOrder        Int?           @default(0)
  parentCategoryId String? // relasi ke kategori induk
  parentCategory   Category?      @relation("CategoryHierarchy", fields: [parentCategoryId], references: [id])
  subcategories    Category[]     @relation("CategoryHierarchy")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  Store            Store[]
  products         Product[]
}

enum CategoryStatus {
  ACTIVE
  INACTIVE
}

// Order status history / timeline entries
model OrderStatusHistory {
  id        String   @id @default(cuid())
  orderId   String
  status    OrderStatus   @default(ORDER_PLACED)
  changedBy String?
  createdAt DateTime @default(now())

  // Relations
  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId])
}

// Enums for reports and priority
enum ReportType {
  PRODUCT
  STORE
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum ReportStatus {
  NEW
  REVIEWED
  IN_PROGRESS
  RESOLVED
  REJECTED
  CLOSED
  ESCALATED
}

// Customer reports / complaints submitted by users
model Report {
  id               String    @id @default(cuid())
  reporterId       String?
  reportType       ReportType
  targetId         String
  // targetName removed: frontend can fetch product/store details using targetId
  subject          String
  message          String   @db.Text
  suggestedPriority Priority?
  priority         Priority  @default(MEDIUM)
  status           ReportStatus @default(NEW)
  category         String?
  attachments      String[]  @default([])
  submittedAt      DateTime  @default(now())
  reviewedAt       DateTime?
  resolvedAt       DateTime?

  // Relation to reporter (User) - optional to allow future anonymous reports if desired
  reporter         User?     @relation("reporterRelation",fields: [reporterId], references: [id])

  PriorityHistory  PriorityHistory[]

  @@index([reportType])
  @@index([status])
}

model PriorityHistory {
  id        String   @id @default(cuid())
  reportId  String
  old       Priority
  new       Priority
  changedBy String?
  reason    String?
  createdAt DateTime @default(now())

  report Report @relation(fields: [reportId], references: [id], onDelete: Cascade)

  @@index([reportId])
}
